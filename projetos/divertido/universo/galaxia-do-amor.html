<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Galáxia do Amor | Universo</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Montserrat:wght@300;500&display=swap"
        rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
        }

        canvas {
            display: block;
        }

        /* UI do player de musica */
        .player-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            z-index: 1000;
            pointer-events: none;
            /* Deixa cliques passarem ao redor dos botoes */
        }

        .player {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 20px;
            border-radius: 20px;
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        .player:hover {
            background: rgba(20, 20, 30, 0.8);
            border-color: rgba(255, 100, 150, 0.3);
            box-shadow: 0 8px 32px rgba(255, 60, 100, 0.2);
        }

        .btn-play {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .btn-play:hover {
            transform: scale(1.1);
            color: #ff3366;
            text-shadow: 0 0 15px #ff3366;
        }

        .progress-wrapper {
            flex-grow: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff3366, #ff9966);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
            transition: width 0.1s linear;
        }

        .time-display {
            font-family: 'Montserrat', monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 80px;
            text-align: right;
        }

        /* Texto sobreposto */
        .overlay-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s ease;
            text-shadow: 0 0 20px rgba(255, 100, 150, 0.5);
            font-family: 'Great Vibes', cursive;
            z-index: 999;
        }

        /* Contador de amor */
        .love-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            text-align: right;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            z-index: 1000;
            user-select: none;
        }

        .love-counter h3 {
            margin: 0 0 5px 0;
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #ff3366;
            text-shadow: 0 0 5px rgba(255, 51, 102, 0.8);
        }

        .love-time {
            font-size: 18px;
            font-family: 'Montserrat', monospace;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div class="overlay-hint" id="hint">Toque para explorar o universo...</div>
    <div class="love-counter">
        <h3>Juntos há</h3>
        <div class="love-time" id="love-timer">Carregando...</div>
    </div>
    <canvas id="c"></canvas>

    <div class="player-container">
        <div class="player">
            <button class="btn-play" id="play-btn">▶</button>
            <div class="progress-wrapper" id="progress">
                <div class="progress-fill" id="progress-bar"></div>
            </div>
            <div class="time-display" id="time">0:00 / 0:00</div>
        </div>
    </div>

    <audio id="audio" loop>
        <source src="quero-ser-seu.mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
    <script>
        // Projeto Universo: Lobinho.IA

        // Logica de audio e UI
        const audio = document.getElementById("audio");
        const playBtn = document.getElementById("play-btn");
        const progress = document.getElementById("progress");
        const progressBar = document.getElementById("progress-bar");
        const timeDisplay = document.getElementById("time");
        const hint = document.getElementById("hint");

        let isPlaying = false;
        let userInteracted = false;

        function formatTime(s) {
            if (!isFinite(s)) return "0:00";
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60).toString().padStart(2, "0");
            return `${m}:${sec}`;
        }

        async function togglePlay() {
            if (!userInteracted) {
                userInteracted = true;
                hint.style.opacity = 0;
            }

            if (isPlaying) {
                audio.pause();
                playBtn.textContent = "▶";
            } else {
                try {
                    await audio.play();
                    playBtn.textContent = "⏸";
                } catch (err) {
                    console.error("Autoplay prevented", err);
                }
            }
            isPlaying = !isPlaying;
        }

        playBtn.addEventListener("click", togglePlay);

        // Oculta dica automaticamente no primeiro clique
        window.addEventListener("click", () => {
            if (!userInteracted) {
                userInteracted = true;
                hint.style.opacity = 0;
            }
        }, { once: true });

        audio.addEventListener("timeupdate", () => {
            const pct = (audio.currentTime / audio.duration) * 100;
            progressBar.style.width = (isFinite(pct) ? pct : 0) + "%";
            timeDisplay.textContent = formatTime(audio.currentTime) + " / " + formatTime(audio.duration);
        });

        progress.addEventListener("click", (e) => {
            const rect = progress.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const pct = clickX / rect.width;
            if (isFinite(audio.duration)) {
                audio.currentTime = pct * audio.duration;
            }
        });

        // Cena do Three.js
        const canvas = document.getElementById("c");
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);

        const scene = new THREE.Scene();
        // Neblina romantica suave
        scene.fog = new THREE.FogExp2(0x000000, 0.0008);

        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 5000);
        let targetDist = 350;
        let currentDist = 350;
        let rotX = 0.5; // Comeca com um angulo legal
        let rotY = 0;

        // Estrelas de fundo (otimizado)
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const count = 3000;
            const posArray = new Float32Array(count * 3);
            for (let i = 0; i < count * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 4000;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const material = new THREE.PointsMaterial({
                size: 2,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        createStars();

        // Sol e asteroides realistas

        // Iluminacao
        const sunLight = new THREE.PointLight(0xffaa33, 2.5, 2000);
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Iluminacao suave para sombras
        scene.add(ambientLight);

        // 1. Sol realista
        function createSun() {
            // Estrela central
            const geometry = new THREE.SphereGeometry(30, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
            });
            const sun = new THREE.Mesh(geometry, material);

            // Brilho da atmosfera (sprite)
            const spriteMat = new THREE.SpriteMaterial({
                map: new THREE.CanvasTexture(generateSunTexture()),
                transparent: true,
                blending: THREE.AdditiveBlending,
                color: 0xff5500
            });
            const glow = new THREE.Sprite(spriteMat);
            glow.scale.set(180, 180, 1);
            sun.add(glow);

            scene.add(sun);
            return { mesh: sun, glow: glow };
        }

        function generateSunTexture() {
            const canvas = document.createElement("canvas");
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext("2d");
            const grad = ctx.createRadialGradient(64, 64, 10, 64, 64, 60);
            grad.addColorStop(0, "rgba(255, 255, 255, 1)");
            grad.addColorStop(0.3, "rgba(255, 200, 100, 0.8)");
            grad.addColorStop(0.7, "rgba(255, 100, 0, 0.2)");
            grad.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 128, 128);
            return canvas;
        }

        const sunSystem = createSun();

        // Texto central (flutuando em frente ao sol)
        function makeCenterTexture(text) {
            const cvs = document.createElement("canvas");
            cvs.width = 1024; // Alta resolucao
            cvs.height = 1024;
            const ctx = cvs.getContext("2d");
            ctx.font = "120px 'Fredoka One', cursive"; // Fonte divertida e legivel
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#ff3366";
            ctx.shadowColor = "#ff0066";
            ctx.shadowBlur = 80;
            ctx.fillText(text, cvs.width / 2, cvs.height / 2);
            return new THREE.CanvasTexture(cvs);
        }
        const centerMat = new THREE.SpriteMaterial({
            map: makeCenterTexture("EU TE AMO ❤️"),
            transparent: true,
            depthWrite: false, // Sempre no topo visualmente, mas atras em profundidade? Nao, desative o depth test para flutuar
            depthTest: false
        });
        const centerSprite = new THREE.Sprite(centerMat);
        centerSprite.scale.set(140, 140, 1);
        centerSprite.renderOrder = 999; // Forca renderizar acima do sol
        scene.add(centerSprite);

        // 2. Cinturao de asteroides (alta variedade e movimento flutuante)
        const asteroidGroup = new THREE.Group();
        scene.add(asteroidGroup);

        // Auxiliar: geometria de coracao
        function createHeartGeometry() {
            const x = 0, y = 0;
            const heartShape = new THREE.Shape();
            heartShape.moveTo(x + .25, y + .25);
            heartShape.bezierCurveTo(x + .25, y + .25, x + .20, y, x, y);
            heartShape.bezierCurveTo(x - .30, y, x - .30, y + .35, x - .30, y + .35);
            heartShape.bezierCurveTo(x - .30, y + .55, x - .10, y + .77, x + .25, y + .95);
            heartShape.bezierCurveTo(x + .60, y + .77, x + .80, y + .55, x + .80, y + .35);
            heartShape.bezierCurveTo(x + .80, y + .35, x + .80, y, x + .50, y);
            heartShape.bezierCurveTo(x + .35, y, x + .25, y + .25, x + .25, y + .25);

            const extrudeSettings = { depth: 0.2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.05, bevelThickness: 0.05 };
            const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            geometry.center(); // Centraliza a geometria
            return geometry;
        }

        // Dados para animacao
        const floatingItems = [];

        function addFloatingType(geometry, material, count, scaleRange) {
            const mesh = new THREE.InstancedMesh(geometry, material, count);
            const dummy = new THREE.Object3D();
            const minRadius = 90;
            const maxRadius = 300;

            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = THREE.MathUtils.lerp(minRadius, maxRadius, Math.random());
                const spreadY = (Math.random() - 0.5) * 40; // Dispersao maior para sensacao de flutuacao

                // Armazena dados de fisica por instancia se quisermos animacao na CPU, 
                // mas para 1500 itens, vamos manter estatico + rotacao do grupo OU 
                // animar um subconjunto. 
                // Para "flutuacao real", use a rotacao padrao e varie os eixos de forma intensa.

                dummy.position.set(
                    Math.cos(angle) * radius,
                    spreadY,
                    Math.sin(angle) * radius
                );

                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

                const s = scaleRange[0] + Math.random() * (scaleRange[1] - scaleRange[0]);
                dummy.scale.set(s, s, s);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);

                // Variacao de cor para cristais
                if (material.type === "MeshPhysicalMaterial") {
                    const hue = Math.random() > 0.5 ? 0.9 : 0.8; // Rosa/roxo
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                    mesh.setColorAt(i, color);
                }
            }

            asteroidGroup.add(mesh);
            return mesh;
        }

        // Tipo 1: Cristais (gemas) - rosa/roxo/diamante
        const crystalGeo = new THREE.OctahedronGeometry(1, 0);
        const crystalMat = new THREE.MeshNormalMaterial({ wireframe: false }); // Fallback temporario
        // Material melhor se o renderer suportar fisico
        const crystalPhysMat = new THREE.MeshPhysicalMaterial({
            roughness: 0.1, transmission: 0.6, thickness: 1, color: 0xffffff
        });
        const crystals = addFloatingType(crystalGeo, crystalPhysMat, 600, [1, 3]);

        // Tipo 2: Pedras brilhantes
        const glowGeo = new THREE.DodecahedronGeometry(1, 0);
        const glowMat = new THREE.MeshStandardMaterial({
            color: 0x222222, emissive: 0x00ffff, emissiveIntensity: 0.8, roughness: 0.4
        });
        // Queremos cores misturadas, entao vamos ajustar a funcao de criacao? 
        // Ou deixar azul/ciano. Vamos fazer um segundo lote para brilho rosa.
        const glowBlue = addFloatingType(glowGeo, glowMat, 300, [1.5, 2.5]);

        const glowMatPink = new THREE.MeshStandardMaterial({
            color: 0x222222, emissive: 0xff00cc, emissiveIntensity: 0.8, roughness: 0.4
        });
        const glowPink = addFloatingType(glowGeo, glowMatPink, 300, [1.5, 2.5]);

        // Tipo 3: Pedras de coracao (easter eggs escondidos)
        const heartGeo = createHeartGeometry();
        const heartRockMat = new THREE.MeshStandardMaterial({
            color: 0xaa5555, roughness: 0.9, flatShading: true
        });
        const heartRocks = addFloatingType(heartGeo, heartRockMat, 200, [2, 4]);

        // Fim de sol e asteroides realistas

        // Palavras flutuantes
        const words = [
            "💖 Meu amor", "🌞 Meu sol", "🌎 Meu mundo", "✨ Paixão", "❤️ Vida",
            "🌌 Universo", "👑 Minha Rainha", "🌠 Luz", "💫 Sonho", "🔥 Desejo",
            "⏳ Pra sempre", "🌹 Flor", "💎 Tesouro", "🦋 Alma", "🌊 Calma",
            "♾️ Eternidade", "💝 Carinho", "🔗 Sintonia", "🧭 Destino", "🥰 Felicidade",
            "🎨 Inspiração", "✨ Meu Tudo", "🌟 Razão"
        ];
        // Multiplica palavras
        const allWords = [...words, ...words, ...words, ...words];

        function makeWordTexture(text, color) {
            const cvs = document.createElement("canvas");
            cvs.width = 512;
            cvs.height = 128;
            const ctx = cvs.getContext("2d");
            ctx.font = "bold 40px 'Montserrat', 'Segoe UI Emoji', 'Apple Color Emoji', 'Symbol', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;
            ctx.fillText(text, cvs.width / 2, cvs.height / 2);
            return new THREE.CanvasTexture(cvs);
        }

        const textGroup = new THREE.Group();
        scene.add(textGroup);

        const paleColors = ["#ff99cc", "#99ccff", "#ffcc99", "#cc99ff", "#ffffff"];

        allWords.forEach((word) => {
            const color = paleColors[Math.floor(Math.random() * paleColors.length)];
            const map = makeWordTexture(word, color);
            const mat = new THREE.SpriteMaterial({ map: map, transparent: true, opacity: 0.8 });
            const sprite = new THREE.Sprite(mat);

            // Distribuicao aleatoria em esfera
            const radius = 180 + Math.random() * 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            sprite.position.x = radius * Math.sin(phi) * Math.cos(theta);
            sprite.position.y = radius * Math.sin(phi) * Math.sin(theta);
            sprite.position.z = radius * Math.cos(phi);

            sprite.scale.set(60, 15, 1);

            // Armazena dados de animacao
            // Extrai emoji (assume que o emoji e a primeira parte da string)
            const emoji = word.split(' ')[0];

            sprite.userData = {
                radius: radius,
                theta: theta,
                phi: phi,
                speed: 0.0005 + Math.random() * 0.001,
                originalScale: sprite.scale.clone(),
                emoji: emoji
            };

            textGroup.add(sprite);
        });

        // 3. Logica de explosao dinamica de emoji
        function createEmojiTexture(emoji) {
            const cvs = document.createElement("canvas");
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext("2d");
            ctx.font = "40px 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(emoji, 32, 34); // Leve deslocamento para centralizar na vertical
            return new THREE.CanvasTexture(cvs);
        }

        const heartParticles = [];
        class Explosion {
            constructor(position, texture) {
                this.particles = [];
                const count = 20; // Menos particulas, mas suficiente
                const geometry = new THREE.BufferGeometry();
                const posArray = new Float32Array(count * 3);

                for (let i = 0; i < count; i++) {
                    posArray[i * 3] = 0; posArray[i * 3 + 1] = 0; posArray[i * 3 + 2] = 0;

                    this.particles.push({
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 3
                        )
                    });
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

                const material = new THREE.PointsMaterial({
                    map: texture,
                    size: 12,
                    transparent: true,
                    opacity: 1,
                    depthWrite: false,
                    color: 0xffffff // Branco para a cor do emoji aparecer
                });

                this.mesh = new THREE.Points(geometry, material);
                this.mesh.position.copy(position);
                scene.add(this.mesh);
                this.life = 1.0;
            }

            update() {
                this.life -= 0.02;
                this.mesh.material.opacity = this.life;
                const positions = this.mesh.geometry.attributes.position.array;

                for (let i = 0; i < this.particles.length; i++) {
                    const v = this.particles[i].velocity;
                    positions[i * 3] += v.x;
                    positions[i * 3 + 1] += v.y;
                    positions[i * 3 + 2] += v.z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
                return this.life > 0;
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        let explosions = [];

        // 1. Estrelas cadentes (versao visivel)
        let shootingStars = [];
        function spawnShootingStar() {
            if (Math.random() > 0.03) return; // 3% de chance

            // Geometria visivel
            const geometry = new THREE.CylinderGeometry(0.4, 0, 60, 8);
            geometry.rotateX(-Math.PI / 2);

            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Inicio aleatorio
            const r = 500;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;

            mesh.position.set(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );

            mesh.lookAt(0, 0, 0);
            scene.add(mesh);
            shootingStars.push({ mesh: mesh, speed: 10 + Math.random() * 5, life: 120 });
        }

        // 5. Contador de amor
        const startDate = new Date("2023-01-01T00:00:00"); // DATA DE INÍCIO - USER_EDIT
        const timerEl = document.getElementById("love-timer");

        function updateCounter() {
            const now = new Date();
            const diff = now - startDate;

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const years = Math.floor(days / 365);
            const remainingDays = days % 365;
            const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
            const minutes = Math.floor((diff / 1000 / 60) % 60);
            const seconds = Math.floor((diff / 1000) % 60);

            timerEl.innerHTML = `${years} Anos, ${remainingDays} Dias<br>${hours}h ${minutes}m ${seconds}s`;
        }
        setInterval(updateCounter, 1000);
        updateCounter();


        // Controles de interacao
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        window.addEventListener('click', e => {
            // Raycasting para coracoes
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(textGroup.children);
            if (intersects.length > 0) {
                const target = intersects[0].object;

                // Obtem o emoji dos dados do usuario ou usa fallback
                const emoji = target.userData.emoji || "💖";
                const tex = createEmojiTexture(emoji);

                // Explosao com emoji especifico
                explosions.push(new Explosion(target.position, tex));

                // Efeito de pop no texto
                const s = target.userData.originalScale;
                target.scale.set(s.x * 1.5, s.y * 1.5, s.z);
                setTimeout(() => {
                    target.scale.copy(s);
                }, 200);
            }
        });

        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            rotY -= deltaX * 0.005;
            rotX -= deltaY * 0.005;
            rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));
            lastX = e.clientX;
            lastY = e.clientY;
        });

        // Suporte a toque
        window.addEventListener('touchstart', e => {
            isDragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        }, { passive: false });
        window.addEventListener('touchend', () => isDragging = false);
        window.addEventListener('touchmove', e => {
            if (!isDragging) return;
            e.preventDefault();
            const deltaX = e.touches[0].clientX - lastX;
            const deltaY = e.touches[0].clientY - lastY;
            rotY -= deltaX * 0.005;
            rotX -= deltaY * 0.005;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        }, { passive: false });

        window.addEventListener('wheel', e => {
            targetDist += e.deltaY * 0.5;
            targetDist = Math.max(100, Math.min(800, targetDist));
        });

        // Loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Suavizacao da camera
            currentDist += (targetDist - currentDist) * 0.05;
            camera.position.x = currentDist * Math.sin(rotY) * Math.cos(rotX);
            camera.position.z = currentDist * Math.cos(rotY) * Math.cos(rotX);
            camera.position.y = currentDist * Math.sin(rotX);
            camera.lookAt(0, 0, 0);

            // Animacao dos objetos
            // Rotacao do cinturao de asteroides (flutuacao caotica)
            asteroidGroup.rotation.y += 0.0005;
            asteroidGroup.rotation.z = Math.sin(time * 0.05) * 0.03;

            // Oscilacoes individuais do grupo
            crystals.rotation.x = Math.sin(time * 0.1) * 0.05;
            glowBlue.rotation.y += 0.0002;
            glowPink.rotation.y -= 0.0002;
            heartRocks.rotation.z += 0.001;

            // Animacao do sol (pulso baseado no tempo)
            sunSystem.glow.material.opacity = 0.6 + Math.sin(time * 1.5) * 0.2;
            const sunScale = 1 + Math.sin(time * 2) * 0.05;
            sunSystem.mesh.scale.set(sunScale, sunScale, sunScale);

            centerSprite.material.opacity = 0.8 + Math.sin(time * 2) * 0.2;
            const scalePulse = 140 + Math.sin(time * 3) * 10;
            centerSprite.scale.set(scalePulse, scalePulse, 1);

            textGroup.children.forEach(sprite => {
                sprite.userData.theta += sprite.userData.speed;
                // Efeito billboard (sempre olha para a camera), mas o sprite padrao ja faz isso
                // Atualiza posicao
                sprite.position.x = sprite.userData.radius * Math.sin(sprite.userData.phi) * Math.cos(sprite.userData.theta);
                sprite.position.y = sprite.userData.radius * Math.sin(sprite.userData.phi) * Math.sin(sprite.userData.theta);
                sprite.position.z = sprite.userData.radius * Math.cos(sprite.userData.phi);
            });

            // Atualiza estrelas cadentes
            spawnShootingStar();
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const s = shootingStars[i];
                s.mesh.translateY(s.speed); // Move para frente (Y e frente por causa da rotacao do cilindro)
                s.life--;
                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    s.mesh.geometry.dispose();
                    s.mesh.material.dispose();
                    shootingStars.splice(i, 1);
                }
            }

            // Atualiza explosoes
            for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions[i].dispose();
                    explosions.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>